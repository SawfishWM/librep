[ This is -*-Indented-Text-*- ]

TODO list for Jade
******************

Bugs are marked !, things that should be done soon are marked +,
and more long-term ideas are marked -

Last modified: May 16, 1998


Outstanding bugs
================

 ! Putting a breakpoint in a .jaderc file doesn't work correctly; the
   debugger is entered, but the commands don't work

 ! How does the return function work with open-coded functions? Not
   very well probably..

 ! Change most uses of make-buffer to use open-buffer, and only
   to open the buffer on demand

 ! The new number parsing code accepts ``0x'' as a valid zero. This
   probably isn't the Right Thing to do

 ! Reverse isearch doesn't update its position if a longer match
   appears as a result of more characters being added to the regexp

 ! C mode still mis-indents some straightforward statements

 ! mail-parse-address doesn't always work. It should really take the
   _list_ of atoms generated by mail-parse-group as its input and scan
   that. (Example of broken address: `Foo "" Bar <foo@bar.com>')

 ! In the prompt, case-insensitive completion has a few wrinkles (like
   deleted characters that are the same across all completions but for
   their case)

 ! The fill-area function still screws up the final line of a buffer

 ! Resizing windows via the window-system sometimes doesn't propagate
   to Jade's perception


General programming tasks:
==========================

 + Add a `batch' mode--don't open any windows, evaluate all command
   line arguments, then exit

 + Move all of lisp/ into lisp-src/ then build into lisp/

 + Remove use of gc_inhibit kludge in streams.c (when calling functions
   that mimic streams)

 + Allow redisplay to be preempted by input becoming available (test
   where in the redisplay algorithms though, in the diff, or the
   drawing, or both!?)

   [ I tried this, using SIGIO, to preempt the make_window_glyphs
     function since the profiler suggested that it's this function
     that takes the most time. The problem was that dragging the mouse
     saturated the input channel, and therefore nothing ever got
     drawn. I need to think this through some more. ]

 + Test defsubst declared functions when dumped

 + Write a buffer compaction function (by improving the locality of
   reference of lines in a buffer, virtual memory performance will be
   greatly improved)

 + Run the thing through a profiler and a test-coverage analyser

 + Clean up the mail-dir interface. Maybe turn it into a fully-fledged
   address book

 + Allow resizing of minibuffer views

 + Allow customisation of status line

 + Bind right mouse button to extend block

 + Make swap-del-bs a runtime option, not compile time

 - Extend the online help

   `C-h m' is the general `context sensitive' help binding. This should
   work in more circumstances, e.g. in prompts

   Allow `links' between help messages

 - Some method of associating ``attributes'' with regions of buffers,
   these attributes would be things like colour, style (bold,
   underline..), and general properties (e.g. read-only, keymaps,
   glyph-tables, etc...). Probably not font-size/family since it's
   nice to keep the idea of a window as a regular grid of glyphs.

 - Allow jadeclient to communicate inter-host.

   What security mechanisms should I use? Xauth is one obvious
   solution, use XauGetAuthByAddr() to get the cookie, then send it
   down the link. Of course, this is no use if the client isn't running
   on an X display; then we could resort to what? Scan the .rhosts
   file? Generate our own magic cookie at server startup? Just allow
   certain hosts and deny others?...

 - Allow dynamic linking and unlinking of C modules (each module would
   only be allowed to define Lisp functions?). This could be useful for
   providing specialised code that can't be written in Lisp..

 - In the Lisp VM replace the `bindstack' list with a vector. Means
   that the compiler will need to track the binding depth as well as
   the stack depth.

 - Use two passes for `concat'; the first pass calculates the new
   string's length, the second builds it

 - Notification of when a file changes externally

 - Change RCS mode to do generic version control, with backends for
   various systems (RCS, SCCS, ...)

   Note that CVS has its own mode since it's conceptually different; it
   deals with groups of files, whereas RCS only worries about files in
   the singular

 - Write a file handler to access remote files. Syntax would be
   something like /[USER@]HOST:FILE-NAME as in Emacs. There are a
   number of ways this can be implemented: rcp, ftp, even using wget
   for read-only access..

   Note that support for "urls as file names" won't be added, since
   urls are a fundamentally different animal to file names. For a
   start, they don't necessarily refer to a static chunk of data (e.g.
   the mailto and telnet types..) find-url handles this problem quite
   adequately I think..

 - Implement an HTML-view mode that renders HTML in one buffer into
   another buffer for viewing

 - Ispell support

 - Handle MIME encoded messages

 - Make the compiler optimise its output

 - Write a LISP module to interface with the PalmPilot (use the
   pilot-link tools to do the messy stuff)

 - Abstract the Lisp extension language into a separate package. Have
   hooks for adding new types, and whatever else is needed. This will
   be quite a big task, since a lot of the code is quite tangled

 - Make the LISP lexically scoped


X11 tasks:
==========

 - Scroll bars, menus. Would it be possible to enable use of GTK at
   compile time? Is it possible to handle multiple displays?

 - `Fuzzy' colour allocation; if a colour can't be allocated find the
   nearest match 


Unix tasks:
===========

 + Use /dev/ptmx to open pseudo-terminals (configuration option), I
   quote from a linux-kernel message:

	"...Opening /dev/ptmx opens the first available master pty; in
	Unix98 conventions, you would then call ptsname() on the open
	file descriptor to get the name of the associated slave pty..."

   And from the Solaris "STREAMS Programming Guide":

	"int fdm fds;
	char *slavename;
	extern char *ptsname();

	fdm = open("/dev/ptmx", O_RDWR);	/* open master */
	grantpt(fdm);				/* change perm. of slave */
	unlockpt(fdm);				/* unlock slave */
	slavename = ptsname(fdm);		/* get name of slave */
	fds = open(slavename, O_RDWR);		/* open slave */
	ioctl(fds, I_PUSH, "ptem");		/* push ptem */
	ioctl(fds, I_PUSH, "ldterm");		/* push ldterm */"

   [ This has been done. I don't know about the generality of the
     I_PUSH stuff though... ]

   Can also send signals via the pty:

	"ioctl (fd, TIOCSIGNAL, SIGINT)"

   sends SIGINT to the slave.


Manual tasks:
=============

 + Update it for version 4. This is a big task.
